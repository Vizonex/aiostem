# -*- coding: utf-8 -*-

import asyncio

from aiostem.command import Command
from types import TracebackType
from typing import Optional, Tuple, Type


DEFAULT_CONTROL_PATH: str = '/var/run/tor/control'
DEFAULT_CONTROL_HOST: str = '127.0.0.1'
DEFAULT_CONTROL_PORT: int = 9051
DEFAULT_PROTOCOL_VERSION: int = 1


class ControllerError(Exception):
    """ Any kind of exception generated by the controller.
    """
    pass
# End of class ControllerError.


class ControlConnector:
    """ Common class for all socket types used by the controller.
    """

    async def connect(self) -> Tuple[asyncio.StreamReader, asyncio.StreamWriter]:
        """ Connect this socket asynchronously.
        """
        raise NotImplementedError('connect() must be implemented by ControlConnector subclass')
# End of class ControlConnector.


class ControlConnectorPort(ControlConnector):
    """ Control socket based on a local or remote TCP port.
    """

    def __init__(self, host: str = DEFAULT_CONTROL_HOST, port: int = DEFAULT_CONTROL_PORT) -> None:
        self._host = host
        self._port = port

    @property
    def host(self) -> str:
        """ IP address to Tor's control port.
        """
        return self._host

    @property
    def port(self) -> int:
        """ TCP port used to join this control port.
        """
        return self._port

    async def connect(self) -> Tuple[asyncio.StreamReader, asyncio.StreamWriter]:
        """ Connect this socket asynchronously.
        """
        return await asyncio.open_connection(self.host, self.port)
# End of class ControlConnectorPort.


class ControlConnectorPath(ControlConnector):
    """ Control socket based on a local UNIX path.
    """

    def __init__(self, path: str = DEFAULT_CONTROL_PATH) -> None:
        self._path = path

    def path(self) -> str:
        """ Get the path provided to connect to Tor's control port.
        """
        return self._path

    async def connect(self) -> Tuple[asyncio.StreamReader, asyncio.StreamWriter]:
        """ Connect this socket asynchronously.
        """
        return await asyncio.open_unix_connection(self.path)
# End of class ControlConnectorPath.


class Controller:
    """ Client controller for Tor's control socket.
    """

    def __init__(self, connector: ControlConnector) -> None:
        self._request_lock = asyncio.Lock()
        self._connected = False
        self._connector = connector
        self._rqueue = None  # type: Optional[asyncio.Queue]
        self._rdtask = None  # type: Optional[asyncio.Task]
        self._writer = None  # type: Optional[asyncio.StreamWriter]

    @classmethod
    def from_port(cls, host: str = DEFAULT_CONTROL_HOST,
                  port: int = DEFAULT_CONTROL_PORT) -> 'Controller':
        """ Create a new Controller from a TCP port.
        """
        connector = ControlConnectorPort(host, port)
        return cls(connector)

    @classmethod
    def from_path(cls, path: str = DEFAULT_CONTROL_PATH) -> 'Controller':
        """ Create a new Controller from a UNIX socket path.
        """
        connector = ControlConnectorPath(path)
        return cls(connector)

    @property
    def connected(self) -> bool:
        """ Whether we are connected to the remote socket.
        """
        return self._connected

    async def __aenter__(self) -> 'Controller':
        """ Enter Controller's context, connect to the target.
        """
        await self.connect()
        return self

    async def __aexit__(self, etype: Optional[Type[BaseException]],
                        evalue: Optional[BaseException],
                        traceback: Optional[TracebackType]) -> None:
        """ Exit Controller's context.
        """
        await self.close()

    async def _reader_task(self, reader):
        """ Read from the socket and dispatch all contents.
        """
        try:
            while True:
                line = await reader.readline()
                if not len(line):
                    print("READER: EOF!")
                    break
                print("READER: " + line.decode('ascii').rstrip())
        finally:
            self._connected = False

    async def request(self, command: Command) -> None:
        """ Send any kind of command to the controller.
            Response is gathered, and expected.
        """
        if not self.connected:
            raise ControllerError('Controller is not connected!')

        async with self._request_lock:
            payload = str(command).encode('ascii')
            self._writer.write(payload)
            await self._writer.drain()

            # TODO: read and return the response from `rqueue`

    async def protocol_info(self, version: int = DEFAULT_PROTOCOL_VERSION) -> None:
        """ Execute command 'PROTOCOLINFO'.
        """
        command = Command('PROTOCOLINFO')
        command.add_argument(str(version))
        return await self.request(command)

    async def connect(self) -> None:
        """ Connect Tor's control socket.
        """
        reader, writer = await self._connector.connect()
        rqueue = asyncio.Queue()
        rdtask = asyncio.create_task(self._reader_task(reader))

        self._connected = True
        self._rqueue = rqueue
        self._rdtask = rdtask
        self._writer = writer

    async def close(self) -> None:
        """ Close this connection and reset the controller.
        """
        writer = self._writer
        if writer is not None:
            writer.close()
            try:
                await writer.wait_closed()
            except BrokenPipeError:
                pass  # can arise while closing underlying UNIX socket
        self._writer = None

        rdtask = self._rdtask
        if rdtask is not None:
            rdtask.cancel()
            try:
                await rdtask
            except asyncio.CancelledError:
                pass

        self._connected = False
        self._rdtask = None
        self._rqueue = None
# End of class Controller.
