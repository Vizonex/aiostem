from __future__ import annotations

from typing import TYPE_CHECKING

from ..reply.base import Event, UnknownEvent
from .hsdesc import HsDescContentEvent, HsDescEvent
from .network import DisconnectEvent, NetworkLivenessEvent
from .signal import SignalEvent
from .status import StatusClientEvent, StatusGeneralEvent, StatusServerEvent

if TYPE_CHECKING:
    from ..message import Message

EVENT_MAP: dict[str, type[Event]] = {
    'DISCONNECT': DisconnectEvent,
    'HS_DESC': HsDescEvent,
    'HS_DESC_CONTENT': HsDescContentEvent,
    'NETWORK_LIVENESS': NetworkLivenessEvent,
    'SIGNAL': SignalEvent,
    'STATUS_CLIENT': StatusClientEvent,
    'STATUS_GENERAL': StatusGeneralEvent,
    'STATUS_SERVER': StatusServerEvent,
}

# The following events are fake and only generated by Aiostem.
EVENTS_INTERNAL: set[str] = {
    'DISCONNECT',
}


def event_parser(message: Message) -> Event:
    """Find the appropriate event class to parse this message."""
    if message.event_type is not None:
        parser = EVENT_MAP.get(message.event_type, UnknownEvent)
    else:  # pragma: no cover
        parser = UnknownEvent
    return parser(message)


__all__ = [
    'EVENTS_INTERNAL',
    'EVENT_MAP',
    'DisconnectEvent',
    'Event',
    'HsDescContentEvent',
    'HsDescEvent',
    'NetworkLivenessEvent',
    'SignalEvent',
    'StatusClientEvent',
    'StatusGeneralEvent',
    'StatusServerEvent',
    'event_parser',
]
