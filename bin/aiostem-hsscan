#!/usr/bin/env python3

import argparse
import asyncio
import contextlib
import os
import sys
from collections.abc import Sequence
from typing import Any, TypeAlias

import aiofiles

from aiostem import Controller
from aiostem.event import Event, HsDescContentEvent
from aiostem.extra import (
    HiddenServiceChecker,
    HiddenServiceFetchError,
    HiddenServiceFetchRequest,
)
from aiostem.util import is_valid_hs_address

HsCallbackResponseType: TypeAlias = HsDescContentEvent | Exception


class HelpFormatter(argparse.HelpFormatter):
    """Change the style of the default help formatter."""

    DEFAULT_MAX_HELP_POSITION: int = 35
    DEFAULT_WIDTH: int = 100

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        """Initialize a new custom formatter."""
        kwargs.setdefault('max_help_position', self.DEFAULT_MAX_HELP_POSITION)
        kwargs.setdefault('width', self.DEFAULT_WIDTH)
        super().__init__(*args, **kwargs)


class HiddenServiceScanner:
    """Example application used to mass-scan hidden service descriptors."""

    DESCRIPTION = 'Check onion domains liveness by requesting directories.'
    DEFAULT_CONTROLLER = '127.0.0.1:9051'
    DEFAULT_TIMEOUT = 60.0
    DEFAULT_WORKERS = 10

    def __init__(self, prog: str) -> None:
        """Create a new hidden service scanner application."""
        self.options = None  # type: argparse.Namespace | None
        self.output = None
        self.parser = self._parser_get(prog)

    @classmethod
    def _parser_get(cls, prog: str) -> argparse.ArgumentParser:
        """Option parser for this application."""
        parser = argparse.ArgumentParser(
            prog=prog,
            description=cls.DESCRIPTION,
            formatter_class=HelpFormatter,
        )
        parser.add_argument(
            '-i',
            '--input',
            metavar='FILE',
            required=True,
            help='input onion domains to scan (one per line)',
        )
        parser.add_argument(
            '-o',
            '--output',
            metavar='FILE',
            help='output list of successfully scanned domains',
        )
        parser.add_argument(
            '-c',
            '--control',
            metavar='SOCK',
            type=str,
            default=cls.DEFAULT_CONTROLLER,
            help="location of Tor's controller (ip:port or path)",
        )
        parser.add_argument(
            '-p',
            '--password',
            metavar='PASS',
            help="optional password to connect to Tor's controller",
        )
        parser.add_argument(
            '-t',
            '--timeout',
            metavar='SECS',
            type=float,
            default=cls.DEFAULT_TIMEOUT,
            help='how long to wait for each descriptor to be fetched',
        )
        parser.add_argument(
            '-w',
            '--workers',
            metavar='NUM',
            type=int,
            default=cls.DEFAULT_WORKERS,
            help='maximum number of concurrent descriptor fetches',
        )
        parser.add_argument(
            '-f',
            '--flush',
            action='store_true',
            help='flush to output file after each write',
        )
        return parser

    @staticmethod
    def _sock_split(sock: str) -> tuple[str, int]:
        """Parse host:port from a string and return both."""
        items = sock.split(':', 1)
        if len(items) == 1:
            items.insert(0, '127.0.0.1')
        return items[0], int(items[1])

    async def _onions_load(self, filepath: str) -> set[str]:
        """Load the input list of onion domains to scan."""
        async with aiofiles.open(filepath, 'r') as fp:
            contents = await fp.read()

        # This generator iterates on all the lines (stripped).
        # It then filters to only keep valid onion domains (suffixed or not).
        lines = map(str.strip, contents.split('\n'))
        return set(filter(lambda x: is_valid_hs_address(x, allow_suffix=True), lines))

    async def _hs_callback(
        self,
        req: HiddenServiceFetchRequest,
        res: HsCallbackResponseType,
    ) -> None:
        """Triggered when we get a scan result.

        Result can either be an exception or the HS_DESC_CONTENT event.
        """
        if isinstance(res, HiddenServiceFetchError):
            print(f'[-] failed to fetch {req.address}.onion (reason: {res!s})')
        elif isinstance(res, Exception):
            print(
                "[-] unexpected error while fetching {}.onion: {}='{}'".format(
                    req.address,
                    type(res).__name__,
                    str(res),
                ),
            )
        else:
            print(
                f"[+] success scanning {req.address}.onion (from directory '{res.directory}')",
            )
            if self.output:
                await self.output.write(f'{req.address}.onion\n')
                if self.options.flush:
                    await self.output.flush()

    async def _hs_check_task(
        self,
        controller: Controller,
        options: argparse.Namespace,
        onions: set[str],
    ) -> None:
        """Task used to check all the provided onions in parallel way."""
        # Create the hidden service checker instance on our brand new controller.
        # Queue is defined here so we don't enqueue everything we have in queue at once.
        checker = HiddenServiceChecker(
            controller,
            concurrency=options.workers,
            queue=asyncio.Queue(maxsize=1000),
        )
        async with checker:
            for address in onions:
                req = HiddenServiceFetchRequest(
                    address,
                    self._hs_callback,
                    timeout=options.timeout,
                )
                await checker.queue.put(req)
            await checker.queue.join()

    async def start(self, args: Sequence[str]) -> None:
        """Parse arguments and run the application."""
        options = self.parser.parse_args(args)
        await self.run(options)

    async def run(self, options: argparse.Namespace) -> None:
        """Check every valid onion domain and write results to an output file."""
        onions = await self._onions_load(options.input)
        self.options = options

        print(f'[+] Loaded a list of {len(onions)} onion domains.')

        async with contextlib.AsyncExitStack() as stack:
            # Open the output file if this was requested.
            if options.output:
                coro = aiofiles.open(options.output, 'w')
                self.output = await stack.enter_async_context(coro)  # type: ignore

            # Find out how we need to connect to our controller.
            if os.path.exists(options.control):
                controller = Controller.from_path(options.control)
            else:
                host, port = self._sock_split(options.control)
                controller = Controller.from_port(host, port)
            controller = await stack.enter_async_context(controller)

            # Authenticate to our Tor controller and request a new identity.
            # This flushes everything left in cache from previous sessions.
            await controller.authenticate(options.password)
            await controller.signal('ACTIVE')
            await controller.signal('NEWNYM')

            res = await controller.get_info('network-liveness')
            status = res.values.get('network-liveness', 'UNKNOWN')
            print(f'[I] Network status is reported to be {status}')

            async def _hs_check_task_cancel(event: Event) -> None:
                """Triggered when the instance gets disconnected from the Controller."""
                print('[!] Controller is disconnected from the control socket!')
                task.cancel('Controller was disconnected from the control socket')

            task = asyncio.create_task(
                self._hs_check_task(controller, options, onions),
                name='aiostem.bin.hsscan.checker',
            )
            await controller.event_subscribe('DISCONNECT', _hs_check_task_cancel)
            await asyncio.gather(task, return_exceptions=True)


if __name__ == '__main__':
    app = HiddenServiceScanner(sys.argv[0])
    res = asyncio.run(app.start(sys.argv[1:]))
    raise SystemExit(res)
