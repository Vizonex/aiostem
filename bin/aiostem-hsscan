#!/usr/bin/env python3

import argparse
import asyncio
import contextlib
import os
import sys
from typing import Optional, Set, Tuple, Union

import aiofiles

from aiostem import Controller
from aiostem.event import DisconnectEvent, HsDescContentEvent
from aiostem.extra import (
    HiddenServiceChecker,
    HiddenServiceFetchError,
    HiddenServiceFetchRequest,
)
from aiostem.util import is_valid_hs_address

HsCallbackResponseType = Union[HsDescContentEvent, Exception]


class HelpFormatter(argparse.HelpFormatter):
    """Change the style of the default help formatter."""

    DEFAULT_MAX_HELP_POSITION: int = 35
    DEFAULT_WIDTH: int = 100

    def __init__(self, *args, **kwargs) -> None:
        kwargs.setdefault('max_help_position', self.DEFAULT_MAX_HELP_POSITION)
        kwargs.setdefault('width', self.DEFAULT_WIDTH)
        super().__init__(*args, **kwargs)


class HiddenServiceScanner:
    """Example application used to mass-scan hidden service descriptors."""

    DESCRIPTION = 'Check onion domains liveness by requesting directories.'
    DEFAULT_CONTROLLER = '127.0.0.1:9051'
    DEFAULT_TIMEOUT = 60.0
    DEFAULT_WORKERS = 10

    def __init__(self, prog: str) -> None:
        self.options = None
        self.output = None
        self.parser = self._parser_get(prog)

    @classmethod
    def _parser_get(cls, prog: str) -> argparse.ArgumentParser:
        """Option parser for this application."""
        parser = argparse.ArgumentParser(
            prog=prog, description=cls.DESCRIPTION, formatter_class=HelpFormatter
        )
        parser.add_argument(
            '-i',
            '--input',
            metavar='FILE',
            required=True,
            help='input onion domains to scan (one per line)',
        )
        parser.add_argument(
            '-o',
            '--output',
            metavar='FILE',
            help='output list of successfully scanned domains',
        )
        parser.add_argument(
            '-c',
            '--control',
            metavar='SOCK',
            type=str,
            default=cls.DEFAULT_CONTROLLER,
            help="location of Tor's controller (ip:port or path)",
        )
        parser.add_argument(
            '-p',
            '--password',
            metavar='PASS',
            help="optional password to connect to Tor's controller",
        )
        parser.add_argument(
            '-t',
            '--timeout',
            metavar='SECS',
            type=float,
            default=cls.DEFAULT_TIMEOUT,
            help='how long to wait for each descriptor to be fetched',
        )
        parser.add_argument(
            '-w',
            '--workers',
            metavar='NUM',
            type=int,
            default=cls.DEFAULT_WORKERS,
            help='maximum number of concurrent descriptor fetches',
        )
        parser.add_argument(
            '-f', '--flush', action='store_true', help='flush to output file after each write'
        )
        return parser

    @staticmethod
    def _sock_split(sock: str) -> Tuple[str, int]:
        """Parses host:port and return both."""
        items = sock.split(':', 1)
        if len(items) == 1:
            items.insert(0, '127.0.0.1')
        return items[0], int(items[1])

    async def _onions_load(self, filepath: str) -> Set[str]:
        """Load the input list of onion domains to scan."""
        async with aiofiles.open(filepath, 'r') as fp:
            contents = await fp.read()

        # This generator iterates on all the lines (stripped).
        # It then filters to only keep valid onion domains (suffixed or not).
        lines = map(str.strip, contents.split('\n'))
        return set(filter(lambda x: is_valid_hs_address(x, allow_suffix=True), lines))

    async def _hs_callback(
        self, req: HiddenServiceFetchRequest, res: HsCallbackResponseType
    ) -> None:
        """The callback triggered when we get a scan result.
        Result can either be an exception or the HS_DESC_CONTENT event.
        """
        if isinstance(res, HiddenServiceFetchError):
            print('[-] failed to fetch {}.onion (reason: {})'.format(req.address, str(res)))
        elif isinstance(res, Exception):
            print(
                "[-] unexpected error while fetching {}.onion: {}='{}'".format(
                    req.address, type(res).__name__, str(res)
                )
            )
        else:
            print(
                "[+] success scanning {}.onion (from directory '{}')".format(
                    req.address, res.directory
                )
            )
            if self.output:
                await self.output.write('{}.onion\n'.format(req.address))
                if self.options.flush:
                    await self.output.flush()

    async def _hs_check_task(self, controller: Controller, onions: Set[str]) -> None:
        """This task is used to check all the provided onions in parallel way."""
        # Create the hidden service checker instance on our brand new controller.
        # Queue is defined here so we don't enqueue everything we have in queue at once.
        checker = HiddenServiceChecker(
            controller, concurrency=self.options.workers, queue=asyncio.Queue(maxsize=1000)
        )
        async with checker:
            for address in onions:
                req = HiddenServiceFetchRequest(
                    address, self._hs_callback, timeout=self.options.timeout
                )
                await checker.queue.put(req)
            await checker.queue.join()

    async def start(self, args) -> None:
        options = self.parser.parse_args(args)
        await self.run(options)

    async def run(self, options) -> Optional[int]:
        """Check every valid onion domain and write results to an output file."""
        onions = await self._onions_load(options.input)
        self.options = options

        print('[+] Loaded a list of {} onion domains.'.format(len(onions)))

        async with contextlib.AsyncExitStack() as stack:
            # Open the output file if this was requested.
            if options.output:
                coro = aiofiles.open(options.output, 'w')
                self.output = await stack.enter_async_context(coro)

            # Find out how we need to connect to our controller.
            if os.path.exists(options.control):
                controller = Controller.from_path(options.control)
            else:
                host, port = self._sock_split(options.control)
                controller = Controller.from_port(host, port)
            controller = await stack.enter_async_context(controller)

            # Authenticate to our Tor controller and request a new identity.
            # This flushes everything left in cache from previous sessions.
            await controller.authenticate(options.password)
            await controller.signal('NEWNYM')

            async def _hs_check_task_cancel(event: DisconnectEvent):
                """Callback used to be notified when this instance get disconnected
                from the remote Tor controller.
                """
                print('[!] Controller is disconnected from the control socket!')
                task.cancel()

            task = asyncio.create_task(self._hs_check_task(controller, onions))
            await controller.event_subscribe('DISCONNECT', _hs_check_task_cancel)
            await asyncio.gather(task, return_exceptions=True)


if __name__ == '__main__':
    app = HiddenServiceScanner(sys.argv[0])
    res = asyncio.run(app.start(sys.argv[1:]))
    raise SystemExit(res)
